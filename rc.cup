
import java_cup.runtime.*;
import java.util.Vector;

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

parser code 
{:
:};

scan with {: return new Symbol (sym.EOF); :};

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

terminal
    T_AMPERSAND,
    T_AND,
    T_ARROW,
    T_ASSIGN,
    T_BAR,
    T_BOOL,
    T_BREAK,
    T_CARET,
    T_CHAR,
    T_CIN,
    T_COLON,
    T_COLONCOLON,
    T_COMMA,
    T_CONST,
    T_CONTINUE,
    T_COUT,
    T_DELETE,
    T_DOT,
    T_ELSE,
    T_ENDL,
    T_EQU,
    T_EXIT,
    T_EXTERN,
    T_FALSE,
    T_FLOAT,
    T_FOR,
    T_FUNCPTR,
    T_FUNCTION,
    T_GT,
    T_GTE,
    T_IF,
    T_INT,
    T_ISTREAM,
    T_LBRACE,
    T_LBRACKET,
    T_LPAREN,
    T_LT,
    T_LTE,
    T_MINUS,
    T_MINUSMINUS,
    T_MOD,
    T_NEQ,
    T_NEW,
    T_NOT,
    T_NULLPTR,
    T_OR,
    T_OSTREAM,
    T_PLUS,
    T_PLUSPLUS,
    T_RBRACE,
    T_RBRACKET,
    T_RETURN,
    T_RPAREN,
    T_SEMI,
    T_SIZEOF,
    T_SLASH,
    T_STAR,
    T_STATIC,
    T_STRUCTDEF,
    T_THIS,
    T_TRUE,
    T_TYPEDEF,
    T_WHILE,
    T_VOID,
    T_AUTO
    ;

terminal String
    T_CHAR_LITERAL,
    T_FLOAT_LITERAL,
    T_INT_LITERAL,
    T_STR_LITERAL,
    T_ID_U,
    T_ID
    ;
    

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

non terminal    
    Program,
    OptGlobalDecls,
    GlobalDecls,
    GlobalDecl,
    FuncDef,
    FuncDecl,
    ExternDecl,
    VarDecl,
    ConstDecl,
    OptStatic,
    TypedefDecl,
    OptRef,
    FieldsList,
    FieldList,
    OptStmtList,
    StmtList,
    Stmt,
    CodeBlock,
    IfStmt,
    OptElse,
    ForStmt,
    WhileStmt,
    BreakStmt,
    ContinueStmt,
    ExitStmt,
    ReturnStmt,
    ReadStmt,
    WriteStmt,
    NewStmt,
    DeleteStmt,
    WritePairList,
    WritePair,
    ConstExpr,
    OptInit,
    ArrElemsList,
    OptModifierList,
    ModifierList,
    Modifier,
    OptArrayDef
    ;

non terminal ParamSTO    
    ParamDecl
    ;

non terminal BinaryOp    
    AddOp,
    Equality,
    MulOp,
    Relation
    ;

non terminal UnaryOp    
    IncDecOp,
    UnarySign
    ;

non terminal STO
    OptExpr,
    Expr,
    Expr0,
    Expr1,
    Expr2,
    Expr3,
    Expr4,
    Expr5,
    Expr6,
    Expr7,
    Expr8,
    Designator,
    Designator2,
    Designator3,
    QualIdent
    ;

non terminal Type
    BasicType,
    SubType,
    Type,
    UndecoratedType,
    ReturnType
    ;
    	
non terminal Vector
    IdList,
    IdListUpper,
    IdListWOptInit,
    IdListWInit,
    OptParamList,
    ParamList,
    OptExprList,
    ExprList
    ;

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

Program ::=         {:
                        ((MyParser) parser).DoProgramStart(); 
                    :}
                    OptGlobalDecls
                    {:
                         ((MyParser) parser).DoProgramEnd();
                    :}
    ;

OptGlobalDecls ::=  GlobalDecls
    |               /* empty */
    ;

GlobalDecls ::=     GlobalDecl
    |               GlobalDecls GlobalDecl
    ;


GlobalDecl ::=      ExternDecl
    |               VarDecl
    |               ConstDecl
    |               TypedefDecl
    |               FuncDecl
    |               FuncDef
    ;

ExternDecl ::=      T_EXTERN Type IdList:_3 T_SEMI
                    {:
                         ((MyParser) parser).DoExternDecl (_3);
                    :}
    ;
    
                                // static int (z = )
VarDecl ::=         OptStatic UndecoratedType:_2 IdListWOptInit:_3 T_SEMI
                    {:
                        ((MyParser) parser).DoVarDecl (_2, _3);
                        // _2: UType
                        // _3: Vector<IdValueTuple>
                    :}
    |               OptStatic T_AUTO T_ID:_1 T_ASSIGN Expr:_2 T_SEMI
                    {:
                        
                    :}

    ;

ConstDecl ::=       OptStatic T_CONST UndecoratedType:_2 IdListWInit:_3 T_SEMI
                    {:
                        ((MyParser) parser).DoConstDecl (_2, _3);
                    :}
    |               OptStatic T_CONST T_AUTO T_ID T_ASSIGN Expr T_SEMI
                    {:
                        
                    :}
    ;


OptStatic ::=       T_STATIC
    |               /* empty */
    ;


TypedefDecl ::=     T_TYPEDEF Type:_1 IdListUpper:_2 T_SEMI                // typedef [type] IDENTIFIER;
                    {:
                        ((MyParser) parser).DoTypedefDecl (_1, _2);
                    :}
    |               T_STRUCTDEF T_ID_U:_1 T_LBRACE                      // structdef IDENTIFIER { [fields] };
                    {:
                        ((MyParser) parser).DoBlockOpen();
                    :}
                    FieldsList T_RBRACE T_SEMI   // ReturnStatement: No
                    {:
                         ((MyParser) parser).DoBlockClose();
                         ((MyParser) parser).DoStructdefDecl (_1);
                    :}
    ;


FieldsList ::=      FieldList
    |               FieldsList FieldList
    ;


FieldList ::=       Type IdList T_SEMI
    |               FuncDef
    ;


FuncDef ::=         T_FUNCTION T_COLON ReturnType:_1 OptRef:_4 T_ID:_2                 // function: [type] & identifier ( param1, param2) { statments } 
                    {:
                        ((MyParser) parser).SaveLineNum ();
                        ((MyParser) parser).DoFuncDecl_1(_1, _2, (Boolean)_4);
                    :}
                    T_LPAREN OptParamList:_3 T_RPAREN
                    {:
                        ((MyParser) parser).DoFormalParams(_3);
                    :}
                    T_LBRACE OptStmtList T_RBRACE  // ReturnStatement: Yes
                    {:
                        ((MyParser) parser).DoFuncDecl_2();
                    :}
    ;

/*
FuncDef:
            function: int foo(int i, int j) 
            {
                // ... statements
            }

FuncDecl:
            function: int foo(int i, int j);


*/


FuncDecl ::=        T_EXTERN T_FUNCTION T_COLON ReturnType:_1 T_ID:_2
                    {:
                        ((MyParser) parser).DoFuncDecl_1(_1, _2, new Boolean(false));
                    :}
                    T_LPAREN OptParamList:_3 T_RPAREN
                    {:
                        ((MyParser) parser).DoFormalParams(_3);
                    :}
                    T_SEMI
                    {:
                        ((MyParser) parser).DoFuncDecl_2();
                    :}
    ;


Type ::=            SubType:_1 OptModifierList OptArrayDef:_3
                    {:
                        if(_3 != null) {
                            RESULT = new ArrayType(_1, _3);      
                        }
                        else {
                            RESULT = _1;
                        }
                    :}
    |               T_FUNCPTR T_COLON ReturnType OptRef T_LPAREN OptParamList:_3 T_RPAREN
    ;

UndecoratedType ::= SubType:_1
                    {:
                        RESULT = _1;
                    :}
    |               T_FUNCPTR T_COLON ReturnType OptRef T_LPAREN OptParamList:_3 T_RPAREN
    ;

SubType ::=         QualIdent:_2
                    {:
                        RESULT = (_2).getType();
                    :}
    |               BasicType:_1
                    {:
                        RESULT = _1;
                    :}
    ;


BasicType ::=       T_INT 
                    {:
                        RESULT = new IntType();
                    :}
    |               T_FLOAT
                    {:
                        RESULT = new FloatType();
                    :}
    |               T_BOOL
                    {:
                        RESULT = new BoolType();
                    :}
    |               T_CHAR
    ;


OptModifierList ::= ModifierList
    |               /* empty */
    ;


ModifierList ::=    Modifier
    |               ModifierList Modifier
    ;


Modifier ::=        T_STAR
    ;


OptArrayDef ::=     T_LBRACKET ConstExpr:_1 T_RBRACKET
                    {:
                        RESULT = _1;
                    :}
    |               /* empty */
    ;


ReturnType ::=      SubType:_1 OptModifierList
                    {:
                        // You should determine the type and return it here
                        // Basic types right now, returned from SubType
                        RESULT = _1;
                    :}
    |               T_VOID
                    {:
                        RESULT = new VoidType();
                    :}
    ;


CodeBlock ::=       T_LBRACE                                                    // CodeBlock is for: 
                    {:                                                          //                  - random { } blocks
                        ((MyParser) parser).DoBlockOpen();                      //                  - if statements 
                    :}                                                          //                  - else statements
                    OptStmtList                                                 //                  - loop statements
		            {:
                        ((MyParser) parser).DoBlockClose(); 
                    :}
                    T_RBRACE    // ReturnStatement: No
    ;


OptStmtList ::=     StmtList
    |               /* empty */
    ;


StmtList ::=        Stmt
    |               StmtList Stmt
    ;


Stmt ::=            VarDecl
    |               ConstDecl
    |               TypedefDecl
    |               CodeBlock
    |               Expr T_SEMI
    |               IfStmt
    |               WhileStmt
    |               ForStmt
    |               BreakStmt
    |               ContinueStmt
    |               ExitStmt
    |               ReturnStmt
    |               ReadStmt
    |               WriteStmt
    |               NewStmt
    |               DeleteStmt
    ;


OptParamList ::=    ParamList:_1
                    {:
                        RESULT = _1;
                    :}
    |               /* empty */
                    {:
                        RESULT = new Vector<ParamSTO>();
                    :}
    ;


ParamList ::=       ParamDecl:_1
                    {:
                        RESULT = new Vector<ParamSTO>();
                        RESULT.addElement(_1);
                    :}
    |               ParamList:_1 T_COMMA ParamDecl:_2
                    {:
                        RESULT = _1;
                        RESULT.addElement(_2);   
                    :}
    ;


ParamDecl ::=       Type:_1 OptRef:_2 T_ID:_3
                    {:
                        RESULT = new ParamSTO(_3, _1, (Boolean)_2);
                    :}
    ;


OptRef ::=          T_AMPERSAND
                    {:
                        RESULT = new Boolean(true);
                    :}
    |               /* empty */
                    {:
                        RESULT = new Boolean(false);
                    :}
    ;


IdList ::=          T_ID:_1
                    {:
                        RESULT = new Vector ();
                        RESULT.addElement (_1);
                    :}
    |               IdList:_1 T_COMMA T_ID:_3
                    {:
                        RESULT = _1;
                        RESULT.addElement (_3);
                    :}
    ;


IdListUpper ::=     T_ID_U:_1
                    {:
                        RESULT = new Vector ();
                        RESULT.addElement (_1);
                    :}
    |               IdListUpper:_1 T_COMMA T_ID_U:_3
                    {:
                        RESULT = _1;
                        RESULT.addElement (_3);
                    :}
    ;


                    // int x = expr2, y = expr

IdListWOptInit ::=  OptModifierList OptArrayDef:_3 T_ID:_1 OptInit:_2
                    {:
                        // _1 is String strID
                        // _2 is STO from DoFuncCall
                        // _3 is ConstExpr in [ConstExpr]

                        RESULT = new Vector<IdValueTuple> ();
                        RESULT.addElement (new IdValueTuple(_1, (STO)_2, (ConstSTO)_3));
                    :}
    |               IdListWOptInit:_1 T_COMMA OptModifierList:_2 OptArrayDef:_5 T_ID:_3 OptInit:_4
                    {:
                        RESULT = _1;
                        RESULT.addElement (new IdValueTuple(_3, (STO)_4, (ConstSTO)_5));
                    :}
    ;
                    // This OptArrayDef not needed because constant arrays WNBT
IdListWInit ::=     OptModifierList OptArrayDef T_ID:_1 T_ASSIGN ConstExpr:_2
                    {:
			            RESULT = new Vector<IdValueTuple>();
			            RESULT.addElement (new IdValueTuple(_1, (STO)_2));
                    :}
    |               IdListWInit:_1 T_COMMA OptModifierList OptArrayDef T_ID:_3 T_ASSIGN ConstExpr:_4
                    {:
			            RESULT = _1;
			            RESULT.addElement (new IdValueTuple(_3, (STO)_4));
		            :}
    ;


OptInit ::=         T_ASSIGN Expr:_1
                    {:
                        // _1: ExprSTO from DoFUncCall
                        RESULT = _1;
                    :}
    |               T_ASSIGN T_LBRACE ArrElemsList T_RBRACE  // ReturnStatement: No             = {ele1, ele2, ..., ele3}
    |               /* empty */
                    {:
                        RESULT = new NullSTO();
                    :}
    ;

ArrElemsList ::=    Expr
    |               ArrElemsList T_COMMA Expr
    ;

IfStmt ::=          T_IF Expr:_1 
                    {:
                        RESULT = ((MyParser) parser).DoIfExpr(_1);
                    :}
                    CodeBlock OptElse
    ;


OptElse ::=         T_ELSE CodeBlock
    |               /* empty */
    ;

WhileStmt ::=       T_WHILE Expr:_1 
                    {:
                        RESULT = ((MyParser) parser).DoWhileExpr(_1);
                    :}
                    CodeBlock
    ;

ForStmt ::=         T_FOR T_LPAREN OptExpr T_SEMI OptExpr T_SEMI OptExpr T_RPAREN CodeBlock
    ;

BreakStmt ::=       T_BREAK T_SEMI
    ;


ContinueStmt ::=    T_CONTINUE T_SEMI
    ;


ExitStmt ::=        T_EXIT T_LPAREN Expr:_1 T_RPAREN T_SEMI
                    {:
                        RESULT = ((MyParser)parser).DoExitStmt(_1);
                    :}
    ;


ReturnStmt ::=      T_RETURN T_SEMI
                    {:
                        RESULT = ((MyParser)parser).DoReturnStmt_1();
                    :}
    |               T_RETURN Expr:_1 T_SEMI
                    {:
                        RESULT = ((MyParser)parser).DoReturnStmt_2(_1);
                    :}
    ;


ReadStmt ::=        T_CIN T_ISTREAM Designator T_SEMI
    ;


WriteStmt ::=       T_COUT T_OSTREAM WritePairList T_SEMI
    ;

NewStmt ::=         T_NEW Designator T_SEMI
    ;

DeleteStmt ::=      T_DELETE Designator T_SEMI
    ;


WritePairList ::=   WritePair
    |               WritePairList T_OSTREAM WritePair
    ;


WritePair ::=       Expr
    |               T_ENDL
    ;


ConstExpr ::=       Expr:_1
                    {:
                        RESULT = _1;
                    :}
    ;


OptExprList ::=     ExprList:_1
                    {:
                        RESULT = _1;
                    :}
    |               /* empty */
                    {:
                        RESULT = new Vector<STO>();
                    :}
    ;


ExprList ::=        Expr:_1
                    {:
                        RESULT = new Vector<STO>();
                        RESULT.addElement(_1);
                    :}
    |               ExprList:_1 T_COMMA Expr:_2
                    {:
                        RESULT = (Vector<STO>)_1;
                        RESULT.addElement(_2);
                    :}
    ;

OptExpr ::=         Expr
    |               /* empty */
    ;


Expr ::=            Designator:_1 T_ASSIGN Expr:_2
                    {:
                        RESULT = ((MyParser) parser).DoAssignExpr (_1, _2);
                    :}
    |               Expr0:_1
                    {:
			            RESULT = _1;
                    :}
    ;


Expr0 ::=           Expr0:_1 T_OR Expr1:_2
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(new OrOp("||"), _1, _2);
                    :}
    |               Expr1:_1
                    {:
			            RESULT = _1;
                    :}
    ;


Expr1 ::=           Expr1:_1 T_AND Expr2:_2
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(new AndOp("&&"), _1, _2);
                    :}
    |               Expr2:_1
                    {:
			            RESULT = _1;
                    :}
    ;


Expr2 ::=           Expr2:_1 T_BAR Expr3:_2
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(new OrBwOp("|"), _1, _2);
                    :}
    |               Expr3:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr3 ::=           Expr3:_1 T_CARET Expr4:_2
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(new XorOp("^"), _1, _2);
                    :}
    |               Expr4:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr4 ::=           Expr4:_1 T_AMPERSAND Expr5:_2
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(new AndBwOp("&"), _1, _2);
                    :}
    |               Expr5:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr5 ::=           Expr5:_1 Equality:_2 Expr6:_3
                    {:
			            RESULT = ((MyParser) parser).DoBinaryOp(_2, _1, _3);
                    :}
    |               Expr6:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr6 ::=           Expr6:_1 Relation:_2 Expr7:_3
                    {:
                        RESULT = ((MyParser) parser).DoBinaryOp(_2, _1, _3);
                    :}
    |               Expr7:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr7 ::=           Expr7:_1 AddOp:_2 Expr8:_3
                    {:
                        RESULT = ((MyParser) parser).DoBinaryOp(_2, _1, _3);
                    :}
    |               Expr8:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Expr8 ::=            Expr8:_1 MulOp:_2 Designator:_3
                    {:
                        RESULT = ((MyParser) parser).DoBinaryOp(_2, _1, _3);
                    :}
    |               Designator:_1
                    {:
                        RESULT = _1;
                    :}
    ;


UnarySign ::=       T_PLUS
                    {:
                        RESULT = new UnPlusOp("+");
                    :}
    |               T_MINUS
                    {:
                        RESULT = new UnMinusOp("-");
                    :}
    ;

Equality ::=        T_EQU
                    {:
                        RESULT = new EqualToOp("==");
                    :}
    |               T_NEQ
                    {:
                        RESULT = new NEqualToOp("!=");
                    :}
    ;


Relation ::=        T_LT
                    {:
                        RESULT = new LessThanOp("<");
                    :}
    |               T_GT
                    {:
                        RESULT = new GreaterThanOp(">");
                    :}
    |               T_LTE
                    {:
                        RESULT = new LessThanEqualOp("<=");
                    :}
    |               T_GTE
                    {:
                        RESULT = new GreaterThanEqualOp(">=");
                    :}
    ;


AddOp ::=           T_PLUS
                    {:
                        RESULT = new AddOp("+");
                    :}
    |               T_MINUS
                    {:
                        RESULT = new MinusOp("-");
                    :}
    ;


MulOp ::=           T_STAR
                    {:
                        RESULT = new MulOp("*");
                    :}
    |               T_SLASH
                    {:
                        RESULT = new DivOp("/");
                    :}
    |               T_MOD
                    {:
                        RESULT = new ModOp("%");
                    :}
    ;


IncDecOp ::=        T_PLUSPLUS
                    {:
                        RESULT = new IncOp("++");
                    :}
    |               T_MINUSMINUS
                    {:
                        RESULT = new DecOp("--");
                    :}
    ;


Designator ::=      T_STAR Designator:_1
                    {:
			            RESULT = _1;
                    :}
    |               T_AMPERSAND Designator:_1
                    {:
			            RESULT = _1;
                    :}
    |               UnarySign Designator:_1
                    {:
			            RESULT = _1;
                    :}
    |               T_NOT Designator:_1
                    {:
			            RESULT = ((MyParser) parser).DoUnaryOp(new NotOp("!"), _1);
                    :}
    |               T_SIZEOF T_LPAREN Designator:_2 T_RPAREN
                    {:
			            RESULT = new ConstSTO("sizeof variable - fix me");
                    :}
    |               T_SIZEOF T_LPAREN Type:_2 T_RPAREN
                    {:
			            RESULT = new ConstSTO("sizeof type - fix me");
                    :}
    |               T_LPAREN Type T_RPAREN Designator:_2
                    {:
			            RESULT = _2;
                    :}
    |               IncDecOp:_1 Designator:_2
                    {:
			            RESULT = ((MyParser) parser).DoUnaryOp(_1, _2);
                    :}
    |               Designator2:_1 
                    {:
                        RESULT = _1;
                    :}
    ;


Designator2 ::=     Designator2:_1 T_DOT T_ID:_3
                    {:
                        RESULT = ((MyParser) parser).DoDesignator2_Dot (_1, _3);
                    :}
    |               Designator2:_1 T_LBRACKET Expr T_RBRACKET
                    {:
                        RESULT = ((MyParser) parser).DoDesignator2_Array (_1);
                    :}
    |               Designator2:_1 T_ARROW T_ID
                    {:
                        RESULT = _1;
                    :}
    |               Designator2:_1 IncDecOp:_2
                    {:
			            RESULT = ((MyParser) parser).DoUnaryOp(_2, _1);
                    :}
    |               Designator2:_1 T_LPAREN OptExprList:_2 T_RPAREN
                    {:
                        RESULT = ((MyParser) parser).DoFuncCall (_1, (Vector<STO>)_2);
                    :}
    |               Designator3:_1
                    {:
                        RESULT = _1;
                    :}
    ;


Designator3 ::=     T_LPAREN Expr:_2 T_RPAREN
                    {:
                        RESULT = _2;
                    :}
    |               T_INT_LITERAL:_1
                    {:
                        RESULT = new ConstSTO (_1, new IntType(), _1);
                    :}
    |               T_FLOAT_LITERAL:_1
                    {:
                        RESULT = new ConstSTO (_1, new FloatType(), _1);
                    :}
    |               T_CHAR_LITERAL:_1
                    {:
                        RESULT = new ConstSTO (_1);
                    :}
    |               T_STR_LITERAL:_1
                    {:
                        RESULT = new ConstSTO (_1);
                    :}
    |               T_TRUE
                    {:
                        RESULT = new ConstSTO ("true", new BoolType(), "true");
                    :}
    |               T_FALSE
                    {:
                        RESULT = new ConstSTO ("false", new BoolType(), "false");
                    :}
    |               T_NULLPTR
                    {:
                        RESULT = new ConstSTO ("nullptr", new NullPtrType());
                    :}
    |               T_THIS
                    {:
                        RESULT = new ConstSTO ("this");
                    :}
    |               T_COLONCOLON T_ID:_1
                    {:
                        RESULT = ((MyParser) parser).DoDesignator3_GlobalID (_1);
                    :}
    |               T_ID:_1
                    {:
                        RESULT = ((MyParser) parser).DoDesignator3_ID (_1);
                    :}
    ;


QualIdent ::=       T_ID_U:_1
                    {:
                       RESULT = ((MyParser) parser).DoQualIdent (_1);
                    :}
    ;
